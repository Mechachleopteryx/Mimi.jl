<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>4 Sensitivity Analysis · Mimi.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Mimi.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../installation/">Installation Guide</a></li><li><a class="tocitem" href="../../userguide/">User Guide</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorial_main/">Tutorials Intro</a></li><li><a class="tocitem" href="../tutorial_1/">1 Run an Existing Model</a></li><li><a class="tocitem" href="../tutorial_2/">2 Modify an Existing Model</a></li><li><a class="tocitem" href="../tutorial_3/">3 Create a Model</a></li><li class="is-active"><a class="tocitem" href>4 Sensitivity Analysis</a><ul class="internal"><li><a class="tocitem" href="#The-API-1"><span>The API</span></a></li><li><a class="tocitem" href="#Two-Region-Model-Example-1"><span>Two-Region Model Example</span></a></li><li><a class="tocitem" href="#Advanced-Post-trial-Functions-1"><span>Advanced Post-trial Functions</span></a></li><li><a class="tocitem" href="#Simulation-Modification-Functions-1"><span>Simulation Modification Functions</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../faq/">FAQ</a></li><li><a class="tocitem" href="../../reference/">Reference</a></li><li><a class="tocitem" href="../../integrationguide/">Integration Guide: Port to v0.5.0</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>4 Sensitivity Analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>4 Sensitivity Analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mimiframework/Mimi.jl/blob/master/docs/src/tutorials/tutorial_4.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Tutorial-4:-Sensitivity-Analysis-(SA)-Support-1"><a class="docs-heading-anchor" href="#Tutorial-4:-Sensitivity-Analysis-(SA)-Support-1">Tutorial 4: Sensitivity Analysis (SA) Support</a><a class="docs-heading-anchor-permalink" href="#Tutorial-4:-Sensitivity-Analysis-(SA)-Support-1" title="Permalink"></a></h1><p>This tutorial walks through the sensitivity analysis (SA) functionality of Mimi, including core routines and examples.  We will start with looking at using the SA routines with the Mimi two-region model provided in the Mimi repository at <code>examples/tutorial/02-two-region-model</code>, and then build out to examine its use on <a href="http://www.fund-model.org">The Climate Framework for Uncertainty, Negotiation and Distribution (FUND)</a>, available on Github <a href="https://github.com/fund-model/fund">here</a>, </p><p>Working through the following tutorial will require:</p><ul><li><a href="https://julialang.org/downloads/">Julia v1.0.0</a> or higher</li><li><a href="https://github.com/mimiframework/Mimi.jl">Mimi v0.6.0</a> </li></ul><p>If you have not yet prepared these, go back to the main tutorial page and follow the instructions for their download.  </p><p>Futhermore, if you are not yet comfortable with downloading (only needs to be done once) and running FUND, refer to Tutorial 1 for instructions.  Carry out <strong>Steps 1 and 2</strong> from Tutorial 1, and then return to continue with this tutorial. Note that FUND is only requred for the second example in this tutorial. </p><h2 id="The-API-1"><a class="docs-heading-anchor" href="#The-API-1">The API</a><a class="docs-heading-anchor-permalink" href="#The-API-1" title="Permalink"></a></h2><p>The best current documentation on the SA API is the internals documentation <a href="https://github.com/anthofflab/Mimi.jl/blob/master/docs/src/internals/montecarlo.md">here</a>, which provides a working and informal description of the Sensitivity Analysis support of Mimi. This file should be used in conjunction with the examples below for details, since the documentation covers more advanced options such as non-stochastic scenarios and running multiple models, which are not yet included in this tutorial.</p><p>These are described further below. We will refer separately to two types, <code>SimulationDef</code> and <code>SimulationInstance</code>.  They are referred to as <code>sim_def</code> and <code>sim_inst</code> respectively as function arguments, and <code>sd</code> and <code>si</code> respectively as local variables.</p><h2 id="Two-Region-Model-Example-1"><a class="docs-heading-anchor" href="#Two-Region-Model-Example-1">Two-Region Model Example</a><a class="docs-heading-anchor-permalink" href="#Two-Region-Model-Example-1" title="Permalink"></a></h2><p>This section will walk through the simple example provided in <code>&quot;Mimi.jl/test/sim/test_defsim.jl&quot;</code>.</p><h3 id="Step-1.-Setup-1"><a class="docs-heading-anchor" href="#Step-1.-Setup-1">Step 1. Setup</a><a class="docs-heading-anchor-permalink" href="#Step-1.-Setup-1" title="Permalink"></a></h3><p>First, set up for the tutorial as follows with the necessary packages and <code>main.jl</code> script for the two-region example.  You should have <code>Mimi</code> installed by now, and if you do not have <code>Distributions</code>, take a moment to add that package using by entering <code>]</code> to enter the <a href="https://docs.julialang.org/en/v1/stdlib/Pkg/index.html">Pkg REPL</a> mode and then typing <code>add Distributions</code>.</p><pre><code class="language-julia">cd(&lt;Mimi-directory-path&gt;) # Mimi-directory-path is a placeholder for the string describing the path of the Mimi directory
using Distributions

include(&quot;examples/tutorial/02-two-region-model/main.jl&quot;)
m = model # defined by 2-region model</code></pre><h3 id="Step-2.-Define-Random-Variables-1"><a class="docs-heading-anchor" href="#Step-2.-Define-Random-Variables-1">Step 2. Define Random Variables</a><a class="docs-heading-anchor-permalink" href="#Step-2.-Define-Random-Variables-1" title="Permalink"></a></h3><p>The <code>@defsim</code> macro, which defines random variables (RVs) which are assigned distributions and associated with model parameters, is the first step in the process. It also selects the sampling method, with simple random sampling being the default. Other options include Latin Hypercube Sampling, and Sobol Sampling.</p><pre><code class="language-julia">sd = @defsim begin
    # Define random variables. The rv() is required to disambiguate an
    # RV definition name = Dist(args...) from application of a distribution
    # to an external parameter. This makes the (less common) naming of an
    # RV slightly more burdensome, but it&#39;s only required when defining
    # correlations or sharing an RV across parameters.
    rv(name1) = Normal(1, 0.2)
    rv(name2) = Uniform(0.75, 1.25)
    rv(name3) = LogNormal(20, 4)

    # If using LHS, you can define correlations like this:
    sampling(LHSData, corrlist=[(:name1, :name2, 0.7), (:name1, :name3, 0.5)])

    # Exclude the sampling() call, or use the following for simple random sampling:
    # sampling(MCSData)

    # For Sobol sampling, specify N, and calc_second_order, which defaults to false.
    # sampling(SobolData, N=100000, calc_second_order=true)

    # assign RVs to model Parameters
    share = Uniform(0.2, 0.8)
    sigma[:, Region1] *= name2
    sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)

    # Assign an array of distributions, keyed by region, to parameter depk
    depk = [Region1 =&gt; Uniform(0.7, 1.3),
            Region2 =&gt; Uniform(0.8, 1.2),
            Region3 =&gt; Normal()]

    # indicate which parameters to save for each model run. Specify
    # a parameter name or [later] some slice of its data, similar to the
    # assignment of RVs, above.
    save(grosseconomy.K, grosseconomy.YGROSS, 
         emissions.E, emissions.E_Global)
end</code></pre><h3 id="Step-3.-Optional-User-Defined-Functions-1"><a class="docs-heading-anchor" href="#Step-3.-Optional-User-Defined-Functions-1">Step 3. Optional User-Defined Functions</a><a class="docs-heading-anchor-permalink" href="#Step-3.-Optional-User-Defined-Functions-1" title="Permalink"></a></h3><p>Next, create the user-defined <code>print_result</code> function, which can be called as a post-trial function by <code>run</code>.</p><pre><code class="language-julia"># Optional user functions can be called just before or after a trial is run
function print_result(m::Model, sim_inst::SimulationInstance, trialnum::Int)
    ci = Mimi.compinstance(m.mi, :emissions)
    value = Mimi.get_variable_value(ci, :E_Global)
    println(&quot;$(ci.comp_id).E_Global: $value&quot;)
end</code></pre><p>where <code>tup</code> is a tuple of scenario arguments representing one element in the cross-product of all scenario value vectors. In situations in which you want the SA loop to run only some of the models, the remainder of the runs can be handled using a <code>pre_trial_func</code> or <code>post_trial_func</code>.</p><h3 id="Step-4.-Run-Simulation-1"><a class="docs-heading-anchor" href="#Step-4.-Run-Simulation-1">Step 4. Run Simulation</a><a class="docs-heading-anchor-permalink" href="#Step-4.-Run-Simulation-1" title="Permalink"></a></h3><p>Finally, use <code>run</code> which runs a simulation, indicating the <code>sim_def</code>, the <code>models</code> is a model, marginal model, or list of models to be run by your <code>sim_def</code> simulation, and <code>samplesize</code> the number of samples to use.</p><p>In it&#39;s simplest use, the <code>run</code> function generates and iterates over generated trial data, perturbing a chosen subset of Mimi&#39;s &quot;external parameters&quot;, based on the defined distributions, and then runs the given Mimi model(s). The function retuns an instance of <code>SimulationInstance</code>, holding a copy of the original <code>SimulationDef</code> in addition to trials information (<code>trials</code>, <code>current_trial</code>, and <code>current_data</code>), the model list<code>models</code>, and results information in <code>results</code>. Optionally, trial values and/or model results are saved to CSV files. Optionally, trial values and/or model results are saved to CSV files.  Note that if there is concern about in-memory storage space for the results, use the <code>results_in_memory</code> flag set to <code>false</code> to incrementally clear the results from memory. View the internals documentation for <strong>critical and useful details on the full signature of this function</strong>:</p><pre><code class="language-none">function Base.run(sim_def::SimulationDef{T}, models::Union{Vector{Model}, Model}, samplesize::Int;
                 ntimesteps::Int=typemax(Int), 
                 trials_output_filename::Union{Nothing, AbstractString}=nothing, 
                 results_output_dir::Union{Nothing, AbstractString}=nothing, 
                 pre_trial_func::Union{Nothing, Function}=nothing, 
                 post_trial_func::Union{Nothing, Function}=nothing,
                 scenario_func::Union{Nothing, Function}=nothing,
                 scenario_placement::ScenarioLoopPlacement=OUTER,
                 scenario_args=nothing,
                 results_in_memory::Bool=true) where T &lt;: AbstractSimulationData</code></pre><p>Here, we first employ <code>run</code> to obtain results:</p><pre><code class="language-julia">
# Run 100 trials and save results to the indicated directories, one CSV file per RV for the results
si = run(sd, m, 100; trials_output_filename = &quot;/tmp/trialdata.csv&quot;, results_output_dir=&quot;/tmp/Mimi&quot;)

# Explore the results saved in-memory
results = getdataframe(si, :grosseconomy, :K) # model index chosen defaults to 1</code></pre><p>and then again using our user-defined post-trial function as the <code>post_trial_func</code> parameter:</p><pre><code class="language-julia"># Same thing but with a post-trial function
si = run(sd, m, 100; trials_output_filename = &quot;/tmp/trialdata.csv&quot;, results_output_dir=&quot;/tmp/Mimi&quot;, post_trial_func=print_result)

# Explore the results saved in-memory
results = getdataframe(si, :grosseconomy, :K) # model index chosen defaults to 1</code></pre><h3 id="Step-5.-Explore-and-Plot-Results-1"><a class="docs-heading-anchor" href="#Step-5.-Explore-and-Plot-Results-1">Step 5. Explore and Plot Results</a><a class="docs-heading-anchor-permalink" href="#Step-5.-Explore-and-Plot-Results-1" title="Permalink"></a></h3><p>As described in the internals documentation <a href="https://github.com/mimiframework/Mimi.jl/blob/master/docs/src/internals/montecarlo.md">here</a>, Mimi provides both <code>explore</code> and <code>Mimi.plot</code> to explore the results of both a run <code>Model</code> and a run <code>SimulationInstance</code>. </p><p>To view your results in an interactive application viewer, simply call:</p><pre><code class="language-julia">explore(si)</code></pre><p>If desired, you may also include a <code>title</code> for your application window. If more than one model was run in your Simulation, indicate which model you would like to explore with the <code>model</code> keyword argument, which defaults to 1. Finally, if your model leverages different scenarios, you <strong>must</strong> indicate the <code>scenario_name</code>.</p><pre><code class="language-julia">explore(si; title = &quot;MyWindow&quot;, model = 1) # we do not indicate scen_name here since we have no scenarios</code></pre><p>To view the results for one of the saved variables from the <code>save</code> command in <code>@defsim</code>, use the (unexported to avoid namespace collisions)<code>Mimi.plot</code> function.  This function has the same keyword arguments and requirements as <code>explore</code>, save for <code>title</code>, and three required arguments: the <code>SimulationInstance</code>, the component name (as a <code>Symbol</code>), and the variable name (as a <code>Symbol</code>).</p><pre><code class="language-julia">using VegaLite
Mimi.plot(si, :grosseconomy, :K)</code></pre><p>To save your figure, use the <code>save</code> function to save typical file formats such as <a href="https://en.wikipedia.org/wiki/Portable_Network_Graphics">PNG</a>, <a href="https://en.wikipedia.org/wiki/Scalable_Vector_Graphics">SVG</a>, <a href="https://en.wikipedia.org/wiki/PDF">PDF</a> and <a href="https://en.wikipedia.org/wiki/Encapsulated_PostScript">EPS</a> files. Note that while <code>explore(sim_inst)</code> returns interactive plots for several graphs, <code>Mimi.plot(si, :foo, :bar)</code> will return only static plots. </p><pre><code class="language-julia">p = Mimi.plot(si, :grosseconomy, :K)
save(&quot;MyFigure.png&quot;, p)</code></pre><h2 id="Advanced-Post-trial-Functions-1"><a class="docs-heading-anchor" href="#Advanced-Post-trial-Functions-1">Advanced Post-trial Functions</a><a class="docs-heading-anchor-permalink" href="#Advanced-Post-trial-Functions-1" title="Permalink"></a></h2><p>While the model above employed a fairly simple <code>post_trial_func</code> that printed out results, the post-trial functions can be used for more complex calculations that need to be made for each simulation run.  This can be especially usefu, for example,for calculating net present value of damages or the social cost of carbon (SCC) for each run.</p><h3 id="NPV-of-Damages-1"><a class="docs-heading-anchor" href="#NPV-of-Damages-1">NPV of Damages</a><a class="docs-heading-anchor-permalink" href="#NPV-of-Damages-1" title="Permalink"></a></h3><p>Case: We want to run MimiDICE2010, varying the climate sensitivity <code>t2xco2</code> over a distribution <code>MyDistribution</code>, and for each run return the sum of discounted climate damages <code>DAMAGES</code> using three different discount rates.</p><p>Without using the Mimi functionality, this may look something like:</p><pre><code class="language-julia"># N = number of trials
# m = DICE2010 model
# df = array of discount factors
# npv_damages= an empty array to store my results
# ECS_sample = a vector of climate sensitivity values drawn from the desired distribution

for i = 1:N
    update_param!(m, :t2xco2, ECS_sample[i])
    run(m)
    npv_damages[i] = sum(df .* m[:neteconomy, :DAMAGES])
end</code></pre><p>We encourage users to employ the Mimi framework for this type of analysis, in large part because the underlying functions have optimizations that will improve speed and memory use, especially as the number of runs climbs.</p><p>Employing the sensitivity analysis functionality could look like the following template:</p><p>First, we define the typical variables for a simulation, including the number of trials <code>N</code> and the simulation definition <code>sim_def</code>.  In this case we only define one random variable, <code>t2xco2</code>, but note there could be any number of random variables defined here.</p><pre><code class="language-julia">using Mimi
using MimiDICE2010

# define your trial number
N = 1000000 

# define your simulation(defaults to Monte Carlo sampling)
sd = @defsim begin
    t2xco2 = MyDistribution()
end</code></pre><p>Next, we consider the requirements for our post-trial function.  We will need to define the array of discount rates <code>discount_rates</code>, and a function that converts <code>discount_rates</code> into the necessary array of discount factors <code>df</code>, as follows.</p><pre><code class="language-julia"># define your desired discount rates and pre compute the discount factors
discount_rates = [0.025, 0.03, 0.05]
dfs = [calculate_df(rate) for rate in discount_rates]    # need to define or replace calculate_df</code></pre><p>Next, we must create an array to store the npv damages results to during the post-trial funciton</p><pre><code class="language-julia"># make an array to store the npv damages results to during the post trial function
npv_results = zeros(N, length(discount_rates))    </code></pre><p>We are now ready to define a post-trial function, which has a required type signature <code>MyFunction(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Tuple)</code> although not all arguments have to be used within the function. Our function will access our model from the list of models in <code>mcs_inst.models</code> (length of one in this case) and then perform calculations on the <code>DAMAGES</code> variable from the <code>neteconomy</code> component in that model as follows.</p><pre><code class="language-julia"># define your post trial function; this is the required type signature, even though we won&#39;t use all of the arguments
function my_npv_calculation(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Tuple)
    m = sim_inst.models[1]    # access the model after it is run for this trial
    damages = m[:neteconomy, :DAMAGES]    # access the damage values for this run
    for (i, df) in enumerate(dfs)    # loop through our precomputed discount factors
        npv_results[trialnum, i] = sum(df .* damages)    # do the npv calculation and save it to our array of results
    end
    nothing    # return nothing
end</code></pre><p>Now that we have defined  our post-trial function, we can set our models and run the simulation! Afterwards, we can use the <code>npv_results</code> array as we need.</p><pre><code class="language-julia">si = run(sd, m, N; post_trial_func = my_npv_calculation, trials_output_filename = &quot;ECS_sample.csv&quot;)# providing a file name is optional; only use if you want to see the climate sensitivity values later

# do something with the npv_results array
println(mean(npv_results, dims=2))    # or write to a file</code></pre><h3 id="Social-Cost-of-Carbon-(SCC)-1"><a class="docs-heading-anchor" href="#Social-Cost-of-Carbon-(SCC)-1">Social Cost of Carbon (SCC)</a><a class="docs-heading-anchor-permalink" href="#Social-Cost-of-Carbon-(SCC)-1" title="Permalink"></a></h3><p>Case: We want to do an SCC calculation across a base and marginal model of <code>MimiDICE2010</code>, which consists of running both a <code>base</code> and <code>marginal</code> model (the latter being a model including an emissions pulse, see the <a href="../../reference/#Mimi.create_marginal_model"><code>create_marginal_model</code></a> or create your own two models). We then take the difference between the <code>DAMAGES</code> in these two models and obtain the NPV to get the SCC.</p><p>The beginning steps for this case are identical to those above. We first define the typical variables for a simulation, including the number of trials <code>N</code> and the simulation definition <code>sim_def</code>.  In this case we only define one random variable, <code>t2xco2</code>, but note there could be any number of random variables defined here.</p><pre><code class="language-julia">using Mimi
using MimiDICE2010

# define your trial number
N = 1000000 

# define your simulation (defaults to Monte Carlo sampling)
sd = @defsim begin
    t2xco2 = MyDistribution()
end</code></pre><p>Next, we prepare our post-trial calculations by setting up a <code>scc_results</code> array to hold the results.  We then define a <code>post_trial_function</code> called <code>my_scc_calculation</code> which will calculate the SCC for that run.</p><pre><code class="language-julia">scc_results = zeros(N, length(discount_rates))

function my_scc_calculation(sim_inst::SimulationInstance, trialnum::Int, ntimesteps::Int, tup::Tuple)
    base, marginal = sim_inst.models
    base_damages = base[:neteconomy, :DAMAGES]
    marg_damages = marginal[:neteconomy, :DAMAGES]
    for (i, df) in enumerate(dfs)
        scc_results[trialnum, i] = sum(df .* (marg_damages .- base_damages))
    end
end</code></pre><p>Now that we have our post-trial function, we can proceed to obtain our two models and run the simulation.</p><pre><code class="language-julia"># Build the base model
base = construct_dice()

#Build the marginal model, which here involves a dummy function `construct_marginal_dice()` that you will need to write
marginal = construct_marginal_dice(year) 

# Run
si = run(sd, [base, marginal], N; trials_output_filename = &quot;ecs_sample.csv&quot;, post_trial_func = my_scc_calculation)</code></pre><h2 id="Simulation-Modification-Functions-1"><a class="docs-heading-anchor" href="#Simulation-Modification-Functions-1">Simulation Modification Functions</a><a class="docs-heading-anchor-permalink" href="#Simulation-Modification-Functions-1" title="Permalink"></a></h2><p>A small set of unexported functions are available to modify an existing <code>SimulationDefinition</code>.  The functions include:</p><ul><li><code>delete_RV!</code></li><li><code>add_RV!</code></li><li><code>replace_RV!</code></li><li><code>delete_transform!</code></li><li><code>add_transform!</code></li><li><code>delete_save!</code></li><li><code>add_save!</code></li><li><code>set_payload!</code></li><li><code>payload</code></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial_3/">« 3 Create a Model</a><a class="docs-footer-nextpage" href="../../faq/">FAQ »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 23 November 2019 04:21">Saturday 23 November 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

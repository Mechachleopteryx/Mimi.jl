# Monte Carlo Simulation support

## Overview

Monte Carlo Simulation support consists of two primary user-facing elements:

1. The `@defmcs` macro, which defines random variables (RVs) which are assigned distributions and associated with model parameters, and
2. The `run_mcs` function, which runs a simulation, with parameters describing the number of trials and callback functions that customize simulation behavior.

These are described further below.

## The @defmcs macro

Monte Carlo Simulations are defined using the macro ```@defmcs```, which does the following:

* Defines random variables (RV) by assigning names to distributions, which can be any object that provides the following function:
  
    `rand(dist, count::Int=1)`

  which produces a single value when `count == 1`, else a `Vector` of values, and if using Latin Hypercube Sampling (LHS), 

  `quantile(dist, quantiles::Vector{Float64})`
  
  which returns values for the given `quantiles` of the distribution.

  In addition to the distributions available in the `Distributions` package, Mimi provides:

  * `EmpiricalDistribution`, which takes a vector of values and (optional) probabilities and produces samples from these values using the given probabilities, if provide, or equal probability otherwise.

  * `SampleStore{T}`, which stores a vector of samples that are produced in order by the `rand` function. This allows the user to to store a predefined set of values (useful for regression testing) and it is used by the LHS method, which draws all required samples at once at equal probability intervals and then shuffles the values. It is also used when rank correlations are specified, since this requires re-ordering draws from random variables.

* Defines how to apply the values generated by each RV to model parameters based on a pseudo-assignment operator:
  * ```param = RV``` replaces the values in the parameter with the value of the RV for the current trial.
  * ```param += RV``` replaces the values in the parameter with the sum of the original value and the value of the RV for the current trial.
  * ```param *= RV``` replaces the values in the parameter with the product of the original value and the value of the RV for the current trial.
* Defines desired rank correlations between pairs of random variables. Note that these cannot be achieved exactly, but in practice, the values are usually fairly close.

The ```@defmcs``` macro returns a ```MonteCarloSimulation``` instance, which contains all the definition information in a form that can be applied at run-time.

## The run_mcs function

In it's simplest use, the `run_mcs` function iterates over a given number of trials, perturbing a chosen set of Mimi's "external parameters", based on the defined distributions, and then runs the given Mimi model. Optionally, trial values and/or model results are saved to CSV files.

### Non-stochastic Scenarios

In many cases, scenarios (which we define as a choice of values from a discrete set for one or more parameters) need to be considered in addition to the stochastic parameter variation. To support scenarios, `run_mcs` also offers iteration over discrete scenario values, which are passed to `run_mcs` via the keyword parameter `scenario_args::Dict{Symbol, Vector}`. For example, to iterate over scenario values "a", and "b", as well as, say, discount rates `0.025, 0.05, 0.07`, you could provide the argument:

`scenario_args=Dict([:name => ["a", "b"], :rate => [0.025, 0.05, 0.07]])`

Of course, the MCS subsystem does not know what you want to do with these values, so the user must also provide a callback function in the `scenario_func` argument. This function must be defined with the signature:

`function any_name_you_like(mcs::MonteCarloSimulation, tup)`

where `tup` is an element of the set of tuples produced by calling `Itertools.product()` on all the scenario arguments. In the example above, this would produce the following vector of tuples:

`[("a", 0.025), ("b", 0.025), ("a", 0.03), ("b", 0.03), ("a", 0.05), ("b", 0.05)]`.

This approach allows all scenario combinations to be iterated over using a single loop. A final keyword argument, `scenario_placement::ScenarioLoopPlacement` indicates whether the scenario loop should occur inside or outside the loop over stochastic trial values. The type `ScenarioLoopPlacement` is an `enum` with values `INNER` and `OUTER`, the latter being the default placement.

In addition to the `scenario_func`, the user can define functions to be called immediately before or after calling `run` on the model. These are passed to `run_mcs` via the keyword arguments `pre_trial_func` and `post_trial_func`, respectively.

In approximate pseudo-julia, these options produce the following behavior:

*scenario_placement=OUTER*
```
for tup in scenario_tuples
  scenario_func(tup)

  # for each scenario, run all MCS trials
  for trial in trials
    trial_data = get_trial_data(trial)
    apply_trial_data()

    pre_trial_func()
    run(model)
    post_trial_func()
  end
end
```

*scenario_placement=INNER*
```   
for trial in trials
  trial_data = get_trial_data(trial)
  apply_trial_data()

  # for each MCS trial, run all scenarios
  for tup in scenario_tuples
    scenario_func(tup)

    pre_trial_func()
    run(model)
    post_trial_func()
  end
end
```

### Running Multiple Models

In some simulations, a baseline model needs to be compared to one or more models that are perturbed parametrically or structurally (i.e., with different components or equations.) To support this, the `MonteCarloSimulation` type holds a vector of `Model` instances, and allows the caller to specify how many of these to run automatically for each trial. Note that regardless of how many models are run, the random variables are applied to all of the models associated with the simulation.

By default, all defined models are run. In some cases, you may want to run some of the models "manually" in the `pre_trial_func` or `post_trial_func`, which allow you to make arbitrary modifications to these additional models.

### Function signature

The full signature for the `run_mcs` is:

```
function run_mcs(mcs::MonteCarloSimulation, 
                 trials::Union{Int, Vector{Int}, Range{Int}},
                 models_to_run::Int=length(mcs.models);
                 ntimesteps::Int=typemax(Int), 
                 output_dir::Union{Void, AbstractString}=nothing, 
                 pre_trial_func::Union{Void, Function}=nothing, 
                 post_trial_func::Union{Void, Function}=nothing,
                 scenario_func::Union{Void, Function}=nothing,
                 scenario_placement::ScenarioLoopPlacement=OUTER,
                 scenario_args=nothing)
```

**Example**

The following example is available in `"Mimi.jl/src/mcs/test_mcs.jl"` branch.

```julia
using Mimi
using Distributions

include("examples/tutorial/02-two-region-model/main.jl")

m = tworegion.my_model

mcs = @defmcs begin
    # Define random variables. The rv() is required to disambiguate an
    # RV definition name = Dist(args...) from application of a distribution
    # to an external parameter. Naming RVs is required only when defining
    # correlations or sharing a single RV across multiple parameters.
    rv(name1) = Normal(1, 0.2)
    rv(name2) = Uniform(0.75, 1.25)
    rv(name3) = LogNormal(20, 4)

    # define (approximate) rank correlations
    name1:name2 = 0.7
    name1:name3 = 0.5

    # assign RVs to model Parameters
    share = Uniform(0.2, 0.8)
    sigma[:, Region1] *= name2

    sigma[2020:5:2050, (Region2, Region3)] *= Uniform(0.8, 1.2)

    # indicate which parameters to save for each model run. Specify
    # a parameter name or [later] some slice of its data, similar to the
    # assignment of RVs, above.
    save(grosseconomy.K, grosseconomy.YGROSS, 
         emissions.E, emissions.E_Global)
end

# Optional user functions can be called just before or after a trial is run
function print_result(m::Model, mcs::MonteCarloSimulation, trialnum::Int)
    ci = Mimi.compinstance(m.mi, :emissions)
    value = Mimi.get_variable_value(ci, :E_Global)
    println("$(ci.comp_id).E_Global: $value")
end

# Generate trial data for all RVs and (optionally) save to a file
generate_trials!(mcs, 1000, filename="/tmp/trialdata.csv")

# Run trials 1:4, and save results to the indicated directory, one CSV file per RV
run_mcs(m, mcs, 4, output_dir="/tmp/Mimi")

# Same thing but with a post-trial function
run_mcs(m, mcs, 4, post_trial_func=print_result, output_dir="/tmp/Mimi")
```

**The remaining sections describe an API that hasn't been developed yet.**

## ModelRunner

There are several types of analyses that require an ensemble of model runs performed over a set of parameter values. These include traditional Monte Carlo simulation, in which random values are drawn from distributions and applied to model parameters, as well as global sensitivity analyses that use prescribed methods for defining trial data (e.g., Sobol sampling), and Markov Chain Monte Carlo, which computes new trial data based on prior model results.

The abstract type ```ModelRunner``` will be used to define a generic API for model runners, including support for parallelization of analyses on multiprocessors and cluster computing systems. The specific sampling and analysis methods required for each subtype of ```ModelRunner``` will be defined in the concrete subtype, e.g., ```MonteCarloRunner```.

The generic process will look something like this:

```julia
m = ModelDef(...)
r = McsRunner(m)

# Optionally redefine random variables, overriding defaults
setrv!(r, :rvname1, Normal(10, 3))

# Optionally assign an alternative RV or distribution to a model parameter
setparam!(r, :comp1, :param1, :rvname1)
setparam!(r, :comp1, :param2, Uniform(0, 3))

# Adjust what should be saved per model run
@add_results(r, param10, param11[US])
@drop_results(r, param1, param1)

# Run trials 1-5000. Also can specify as a range (e.g., 5001:10000) 
# or vector of trial numbers.
run!(r, 5000)

# Save results to the indicated directory
write(r, dirname)
```

### Saving ensemble results

Ensemble results will be stored in an object of type ```EnsembleResult```, which is used by all subtypes of ```ModelRunner```. By default, only model outputs tagged for output will be saved in the ```EnsembleResult``` instance. Parameters can be identified as "output" parameters in ```@defmcs```, and/or directly in a concrete subtype of ```ModelRunner```, in which case default values set in ```@defmcs``` can be overridden.

The method ```write(r::ModelRunner, dirname::String)``` will save model results to set of CSV files in the named directory. Initially, we will store the data in [tidy](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html) format in which variables are in columns and each row represents an observation. This format is verbose but flexible and commonly used by consumers of data such as plotting packages. Other formats can be generated if the need arises.

In the initial implementation, results will be saved as follows:

* Scalar model results will be written to ```"$dirname/scalars.csv"```. The file will have a column holding the trial number, and one column labeled with each parameter name. Each row in the file will contain all scalar parameter values data for a single  model run. 
  * Example:

    | trialnum | foo | bar | baz | ... |
    | -------- | --- | --- | --- | --- |
    | 1        | 1.6 | 0.4 | 110 | ... |

  * Alternatively, we could flatten to 3 columns: 

    | trialnum | paramname | value |
    | -------- | --------- | ----- |
    | 1        | foo       | 1.6   |
    | 1        | bar       | 0.4   |
    | 1        | baz       | 110   |

* All model results with a single time dimension will be written to ```"$dirname/timeseries.csv"```, with columns:

  | trialnum | year | foo   | bar  | baz  | ... |
  | -------- | ---- | ----- | ---- | ---- | --- |
  | 1        | 2010 | 100.6 | 41.6 | 9.1  | ... |
  | 1        | 2015 | 101.7 | 44.5 | 10.2 | ... |
  | 1        | 2020 | 102.8 | 50.1 | 12.4 | ... |
  | ...      | ...  | ...   | ...  | ...  | ... |
  | 2        | 2010 | 101.6 | 43.7 | 10.4 | ... |
  | 2        | 2015 | 102.4 | 60.1 | 21.3 | ... |
  | 2        | 2020 | 105.7 | 55.3 | 14.2 | ... |
  | ...      | ...  | ...   | ...  | ...  | ... |

  * As with scalar results, this might be flattened further to:

    | trialnum | paramname | year | value |
    | -------- | --------- | ---- | ----- |
    | 1        | foo       | 2010 | 100.6 |
    | 1        | foo       | 2015 | 101.7 |
    | 1        | foo       | 2020 | 102.8 |
    | ...      | ...       | ...  | ...   |
    | 2        | foo       | 2010 | 101.6 |
    | 2        | foo       | 2015 | 102.4 |
    | 2        | foo       | 2020 | 105.7 |
    | ...      | ...       | ...  | ...   |

  * Another alternative would be to store each timeseries result to its own CSV file, in which case the second (flattened) format would be used, minus the "paramname" column, which would be implicit from the filename. This would be more consistent with the matrix format below, since a timeseries result is just a matrix result with only one dimension.

* Matrix results will be saved to individual files named ```"$dirname/$paramname.csv"```. Matrices will be flattened so that each dimension appears as a column. For example, a matrix with dimensions "time" and "region" will have columns "trialnum", 

  | trialnum | region | year | value |
  | -------- | ------ | ---- | ----- |
  | 1 | US | 2010 | 1.1 |
  | 1 | US | 2015 | 1.9 |
  | ...|
  | 1 | CHI | 2010 | 0.2 |
  | 1 | CHI | 2015 | 0.8 |
  | ...|
  
* Another option for saving ensemble outputs might include writing to any "sink" type that accepts named tuples.

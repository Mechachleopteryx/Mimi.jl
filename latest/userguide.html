<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User Guide · Mimi.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Mimi.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="installation.html">Installation Guide</a></li><li class="current"><a class="toctext" href="userguide.html">User Guide</a><ul class="internal"><li><a class="toctext" href="#Overview-1">Overview</a></li><li><a class="toctext" href="#Defining-Components-1">Defining Components</a></li><li><a class="toctext" href="#Constructing-a-Model-1">Constructing a Model</a></li><li><a class="toctext" href="#Running-a-Model-1">Running a Model</a></li><li><a class="toctext" href="#Accessing-Results-1">Accessing Results</a></li><li><a class="toctext" href="#Plotting-1">Plotting</a></li><li><a class="toctext" href="#Advanced-Topics-1">Advanced Topics</a></li></ul></li><li><a class="toctext" href="tutorial.html">Tutorial</a></li><li><a class="toctext" href="faq.html">FAQ</a></li><li><a class="toctext" href="reference.html">Reference</a></li><li><a class="toctext" href="integrationguide.html">Integration Guide</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="userguide.html">User Guide</a></li></ul><a class="edit-page" href="https://github.com/anthofflab/Mimi.jl/blob/master/docs/src/userguide.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>User Guide</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="User-Guide-1" href="#User-Guide-1">User Guide</a></h1><h2><a class="nav-anchor" id="Overview-1" href="#Overview-1">Overview</a></h2><p>See the Tutorial for in depth examples of one-region and multi-region models.</p><p>This guide is organized into six main sections for understanding how to use Mimi.</p><ol><li><p>Defining components</p></li><li><p>Constructing a model</p></li><li><p>Running the model</p></li><li><p>Accessing results</p></li><li><p>Plotting</p></li><li><p>Advanced topics</p></li></ol><h2><a class="nav-anchor" id="Defining-Components-1" href="#Defining-Components-1">Defining Components</a></h2><p>Any Mimi model is made up of at least one component, so before you construct a model, you need to create your components.</p><p>A component can have any number of parameters and variables. Parameters are data values that will be provided to the component as input, and variables are values that the component will calculate in the run_timestep function when the model is run. The index of a parameter or variable determines the number of dimensions that parameter or variable has. They can be scalar values and have no index, such as parameter &#39;c&#39; in the example below. They can be one-dimensional, such as the variable &#39;A&#39; and the parameters &#39;d&#39; and &#39;f&#39; below. They can be two dimensional such as variable &#39;B&#39; and parameter &#39;e&#39; below. Note that any index other than &#39;time&#39; must be declared at the top of the component, as shown by <code>regions = Index()</code> below.</p><p>The user must define a run_timestep function for each component. </p><p>We define a component in the following way:</p><pre><code class="language-julia">using Mimi

@defcomp MyComponentName begin
  regions = Index()

  A = Variable(index = [time])
  B = Variable(index = [time, regions])

  c = Parameter()
  d = Parameter(index = [time])
  e = Parameter(index = [time, regions])
  f = Parameter(index = [regions])

  function run_timestep(p, v, d, t)
    vars.A[t] = params.c + params.d[t]
    for r in dims.regions
      vars.B[t, r] = params.f[r] * params.e[t, r]
    end
  end

end
</code></pre><p>The run_timestep function is responsible for calculating values for each variable in that component.  Note that the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined. You can access each parameter, variable, or dimension using dot notation as shown above.  The fourth argument is an <code>AbstractTimestep</code>, i.e., either a <code>FixedTimestep</code> or a <code>VariableTimestep</code>, which represents which timestep the model is at.</p><p>The API for using the fourth argument, represented as <code>t</code> in this explanation, is described in this document under <strong>Advanced Topics:  Timesteps and available functions</strong>. </p><p>To access the data in a parameter or to assign a value to a variable, you must use the appropriate index or indices (in this example, either the Timestep or region or both).</p><h2><a class="nav-anchor" id="Constructing-a-Model-1" href="#Constructing-a-Model-1">Constructing a Model</a></h2><p>The first step in constructing a model is to set the values for each index of the model. Below is an example for setting the &#39;time&#39; and &#39;regions&#39; indexes. The time index expects either a numerical range or an array of numbers.  If a single value is provided, say &#39;100&#39;, then that index will be set from 1 to 100. Other indexes can have values of any type.</p><pre><code class="language-julia">mymodel = Model()
set_dimension!(mymodel, :time, 1850:2200)
set_dimension!(mymodel, :regions, [&quot;USA&quot;, &quot;EU&quot;, &quot;LATAM&quot;])
</code></pre><p><em>A Note on Time Indexes:</em> It is important to note that the values used for the time index are the <em>start times</em> of the timesteps.  If the range or array of time values has a uniform timestep length, the model will run <em>through</em> the last year of the range with a last timestep period length consistent with the other timesteps.  If the time values are provided as an array with non-uniform timestep lengths, the model will run <em>through</em> the last year in the array with a last timestep period length <em>assumed to be one</em>. </p><p>The next step is to add components to the model. This is done by the following syntax:</p><pre><code class="language-julia">add_comp!(mymodel, ComponentA, :GDP)
add_comp!(mymodel, ComponentB; first=2010)
add_comp!(mymodel, ComponentC; first=2010, last=2100)
</code></pre><p>The first argument to add_comp! is the model, the second is the name of the ComponentId defined by @defcomp. If an optional third symbol is provided (as in the first line above), this will be used as the name of the component in this model. This allows you to add multiple versions of the same component to a model, with different names. You can also have components that do not run for the full length of the model. You can specify custom first and last times with the optional keyword arguments as shown above. If no first or last time is provided, the component will assume the first or last time of the model&#39;s time index values that were specified in set_dimension!.</p><p>The next step is to set the values for all the parameters in the components. Parameters can either have their values assigned from external data, or they can internally connect to the values from variables in other components of the model.</p><p>To make an external connection, the syntax is as follows:</p><pre><code class="language-julia">set_param!(mymodel, :ComponentName, :parametername, 0.8) # a scalar parameter
set_param!(mymodel, :ComponentName, :parametername2, rand(351, 3)) # a two-dimensional parameter
</code></pre><p>To make an internal connection, the syntax is as follows.  Note that there is an optional keyword argument offset, that should be used in the case that a component parameter is connected to a variable from a prior timestep to prevent a cycle.  The offset value is an <code>Int</code> specifying the offset in terms of timesteps.</p><pre><code class="language-julia">connect_param!(mymodel, :TargetComponent=&gt;:parametername, :SourceComponent=&gt;:variablename)
# Note: offset=1 =&gt; dependence is on on prior timestep, i.e., not a cycle
connect_param!(mymodel, :TargetComponent=&gt;:parametername, :SourceComponent=&gt;:variablename, offset = 1)</code></pre><p>If you wish to delete a component that has already been added, do the following:</p><pre><code class="language-julia">delete!(mymodel, :ComponentName)</code></pre><p>This will delete the component from the model and remove any existing connections it had. Thus if a different component was previously connected to this component, you will need to connect its parameter(s) to something else.</p><h2><a class="nav-anchor" id="Running-a-Model-1" href="#Running-a-Model-1">Running a Model</a></h2><p>After all components have been added to your model and all parameters have been connected to either external values or internally to another component, then the model is ready to be run. Note: at each timestep, the model will run the components in the order you added them. So if one component is going to rely on the value of another component, then the user must add them to the model in the appropriate order.</p><pre><code class="language-julia">run(mymodel)
</code></pre><h2><a class="nav-anchor" id="Accessing-Results-1" href="#Accessing-Results-1">Accessing Results</a></h2><p>After a model has been run, you can access the results (the calculated variable values in each component) in a few different ways.</p><p>You can use the <code>getindex</code> syntax as follows:</p><pre><code class="language-julia">mymodel[:ComponentName, :VariableName] # returns the whole array of values
mymodel[:ComponentName, :VariableName][100] # returns just the 100th value
</code></pre><p>Indexing into a model with the name of the component and variable will return an array with values from each timestep. You can index into this array to get one value (as in the second line, which returns just the 100th value). Note that if the requested variable is tow-dimensional, then a 2-D array will be returned.</p><p>You can also get data in the form of a dataframe, which will display the corresponding index labels rather than just a raw array. The syntax for this is:</p><pre><code class="language-julia">getdataframe(mymodel, :ComponentName=&gt;:Variable) # request one variable from one component
getdataframe(mymodel, :ComponentName=&gt;(:Variable1, :Variable2)) # request multiple variables from the same component
getdataframe(mymodel, :Component1=&gt;:Var1, :Component2=&gt;:Var2) # request variables from different components
</code></pre><h2><a class="nav-anchor" id="Plotting-1" href="#Plotting-1">Plotting</a></h2><p><img src="figs/plotting_example.png" alt="Plotting Example"/></p><p>Mimi provides support for plotting using the <a href="https://github.com/tbreloff/Plots.jl">Plots</a> module. Mimi extends Plots by adding an additional method to the <code>Plots.plot</code> function. Specifically, it adds a new method with the signature</p><pre><code class="language-julia">function Plots.plot(m::Model, component::Symbol, parameter::Symbol ; index::Symbol, legend::Symbol, x_label::String, y_label::String)</code></pre><p>A few important things to note:</p><ul><li><p>The model <code>m</code> must be built and run before it is passed into <code>plot</code></p></li><li><p><code>index</code>, <code>legend</code>, <code>x_label</code>, and <code>y_label</code> are optional keyword arguments. If no values are provided, the plot will index by <code>time</code> and use the data it has to best fill in the axis labels.</p></li><li><p><code>legend</code> should be a <code>Symbol</code> that refers to an index on the model set by a call to <code>setindex</code></p></li></ul><p>This method returns a <span>$Plots.Plot$</span> object, so calling it in an instance of an IJulia Notebook will display the plot. Because this method is defined on the Plots package, it is easy to use the other features of the Plots package. For example, calling <code>savefig(&quot;x&quot;)</code> will save the plot as <code>x.png</code>, etc. See the <a href="https://juliaplots.github.io/">Plots Documentaton</a> for a full list of capabilities.</p><h2><a class="nav-anchor" id="Advanced-Topics-1" href="#Advanced-Topics-1">Advanced Topics</a></h2><h3><a class="nav-anchor" id="Timesteps-and-available-functions-1" href="#Timesteps-and-available-functions-1">Timesteps and available functions</a></h3><p>An <code>AbstractTimestep</code> i.e. a <code>FixedTimestep</code> or a <code>VariableTimestep</code> is a type defined within Mimi in &quot;src/time.jl&quot;. It is used to represent and keep track of time indices when running a model.</p><p>In the run_timestep functions which the user defines, it may be useful to use any of the following functions, where <code>t</code> is an AbstractTimestep object:</p><pre><code class="language-julia">is_first(t) # returns true or false, true if t is the first timestep to be run
is_last(t) # returns true or false, true if t is the last timestep to be run
gettime(t) # returns the year represented by timestep t</code></pre><p>The API details for AbstractTimestep object <code>t</code> are as follows:</p><ul><li><p>you may index into a variable or parameter with <code>[t]</code> or <code>[t +/- x]</code> as usual</p></li><li><p>to access the time value of <code>t</code> (currently a year) as a <code>Number</code>, use <code>gettime(t)</code></p></li><li><p>useful functions for commonly used conditionals are <code>is_first(t)</code>,<code>is_last(t)</code>, as listed above</p></li><li><p>to access the index value of <code>t</code> as a <code>Number</code> representing the position in the time array, use <code>t.t</code>.  Users are encouraged to avoid this access, and instead use the options listed above or a separate counter variable. each time the function gets called. </p></li></ul><h3><a class="nav-anchor" id="Parameter-connections-between-different-length-components-1" href="#Parameter-connections-between-different-length-components-1">Parameter connections between different length components</a></h3><p>As mentioned earlier, it is possible for some components to start later or end sooner than the full length of the model. This presents potential complications for connecting their parameters. If you are setting the parameters to external values, then the provided values just need to be the right size for that component&#39;s parameter. If you are making an internal connection, this can happen in one of two ways:</p><ol><li><p>A shorter component is connected to a longer component. In this case, nothing additional needs to happen. The shorter component will pick up the correct values it needs from the longer component.</p></li><li><p>A longer component is connected to a shorter component. In this case, the shorter component will not have enough values to supply to the longer component. In order to make this connection, the user must also provide an array of backup data for the parameter to default to when the shorter component does not have values to give. Do this in the following way:</p></li></ol><pre><code class="language-julia">backup = rand(100) # data array of the proper size
connect_param!(mymodel, :LongComponent=&gt;:parametername, :ShortComponent=&gt;:variablename, backup)</code></pre><p>Note: for now, to avoid discrepancy with timing and alignment, the backup data must be the length of the whole component&#39;s first to last time, even though it will only be used for values not found in the shorter component.</p><h3><a class="nav-anchor" id="More-on-parameter-indices-1" href="#More-on-parameter-indices-1">More on parameter indices</a></h3><p>As mentioned above, a parameter can have no index (a scalar), or one or multiple of the model&#39;s indexes. A parameter can also have an index specified in the following ways:</p><pre><code class="language-julia">@defcomp MyComponent begin
  p1 = Parameter(index=[4]) # an array of length 4
  p2::Array{Float64, 2} = Parameter() # a two dimensional array of unspecified length
end</code></pre><p>In both of these cases, the parameter&#39;s values are stored of as an array (p1 is one dimensional, and p2 is two dimensional). But with respect to the model, they are considered &quot;scalar&quot; parameters, simply because they do not use any of the model&#39;s indices (namely &#39;time&#39;, or &#39;regions&#39;).</p><h3><a class="nav-anchor" id="Updating-an-external-parameter-1" href="#Updating-an-external-parameter-1">Updating an external parameter</a></h3><p>When <code>set_param!</code> is called, it creates an external parameter by the name provided, and stores the provided value(s). It is possible to later change the value(s) associated with that parameter name. Use the following available function:</p><pre><code class="language-julia">update_external_param(mymodel, :parametername, newvalues)</code></pre><p>Note: newvalues must be the same size and type (or be able to convert to the type) of the old values stored in that parameter.</p><h3><a class="nav-anchor" id="Setting-parameters-with-a-dictionary-1" href="#Setting-parameters-with-a-dictionary-1">Setting parameters with a dictionary</a></h3><p>In larger models it can be beneficial to set some of the external parameters using a dictionary of values. To do this, use the following function:</p><pre><code class="language-julia">set_leftover_params!(mymodel, parameters)</code></pre><p>Where <code>parameters</code> is a dictionary of type <code>Dict{String, Any}</code> where the keys are strings that match the names of the unset parameters in the model, and the values are the values to use for those parameters.</p><h3><a class="nav-anchor" id="Using-NamedArrays-for-setting-parameters-1" href="#Using-NamedArrays-for-setting-parameters-1">Using NamedArrays for setting parameters</a></h3><p>When a user sets a parameter, Mimi checks that the size and dimensions match what it expects for that component. If the user provides a NamedArray for the values, Mimi will further check that the names of the dimensions match the expected dimensions for that parameter, and that the labels match the model&#39;s index values for those dimensions. Examples of this can be found in &quot;test/test_parameter_labels.jl&quot;.</p><h3><a class="nav-anchor" id="The-internal-&#39;build&#39;-function-and-model-instances-1" href="#The-internal-&#39;build&#39;-function-and-model-instances-1">The internal &#39;build&#39; function and model instances</a></h3><p>When you call the run function on your model, first the internal <code>build</code> function is called, which produces a ModelInstance, and then the ModelInstance is run. A model instance is an instantiated version of the model you have designed where all of the component constructors have been called and all of the data arrays have been allocated. If you wish to create and run multiple versions of your model, you can use the intermediate build function and store the separate ModelInstances. This may be useful if you want to change some parameter values, while keeping the model&#39;s structure mostly the same. For example:</p><pre><code class="language-julia">instance1 = Mimi.build(mymodel)
run(instance1)

update_external_param(mymodel, paramname, newvalue)
instance2 = Mimi.build(mymodel)
run(instance2)

result1 = instance1[:Comp, :Var]
result2 = instance2[:Comp, :Var]
</code></pre><p>Note that you can retrieve values from a ModelInstance in the same way previously shown for indexing into a model.</p><h3><a class="nav-anchor" id="The-init-function-1" href="#The-init-function-1">The init function</a></h3><p>The <code>init</code> function can optionally be called within <code>@defcomp</code> and <strong>before</strong> <code>run_timestep</code>.  Similarly to <code>run_timestep</code>, this function is called with parameters <code>init(p, v, d)</code>, where the component state (defined by the first three arguments) has fields for the Parameters, Variables, and Dimensions of the component you defined.   </p><p>If defined for a specific component, this function will run <strong>before</strong> the timestep loop, and should only be used for parameters or variables without a time index e.g. to compute the values of scalar variables that only depend on scalar parameters. Note that when using <code>init</code>, it may be necessary to add special handling in the <code>run_timestep</code> function for the first timestep, in particular for difference equations.  A skeleton <code>@defcomp</code> script using both <code>run_timestep</code> and <code>init</code> would appear as follows:</p><pre><code class="language-julia">@defcomp component1 begin

    # First define the state this component will hold
    savingsrate = Parameter()

    # Second, define the (optional) init function for the component
    function init(p, v, d)
    end

    # Third, define the run_timestep function for the component
    function run_timestep(p, v, d, t)
    end

end</code></pre><h3><a class="nav-anchor" id="The-explorer-UI-1" href="#The-explorer-UI-1">The explorer UI</a></h3><p>The <code>explore</code> function allows the user to view and explore the variables and parameters of a model run.  To invoke the explorer UI, simply call the function <code>explore</code> with the model run as the required argument, and a window title as an optional keyword argument, as shown below.  This will produce a new browser window containing a selectable list of parameters and variables, organized by component, each of which produces a graphic.  The exception here being that if the parameter or variable is a single scalar value, the value will appear alongside the name in the left-hand list.</p><p>```julia  run1 = run(my_model)  explore(run1, title = &quot;run1 results&quot;)</p><p>```</p><footer><hr/><a class="previous" href="installation.html"><span class="direction">Previous</span><span class="title">Installation Guide</span></a><a class="next" href="tutorial.html"><span class="direction">Next</span><span class="title">Tutorial</span></a></footer></article></body></html>
